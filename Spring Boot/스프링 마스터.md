
## 스프링 부트란 무엇인가

스프링 부트는 스프링 포트폴리오를 신속하게, 미리 정의된 방식으로, 이식성 있게. 실제 서비스 환경에 사용할 수 있도록 조립해놓은 것이다.

- <span style="color:9999ff">신속성</span>: 의존관계를 포함해서 애플리케이션의 여러 요소에 기반한 의사결정을 신속히 적용할 수 있게 해주므로 애플리케이션 개발 속도를 높이는 데 도움을 준다.
- <span style="color:9999ff">미리 정의된 방식</span>
- <span style="color:9999ff">이식성</span>: JDK가 있는 곳이라면 스프링 부트 애플리케이션은 어디에서나 실행될 수 있다. 특정한 인증을 받은 애플리케이션 서버나 특정 벤더 제품을 필요로 하지 않음, 스프링 부트의 도구를 사용해 패키지를 만들면 어디든 배포해서 실행할 수 있다.
- <span style="color:9999ff">실제 서비스 환경에 사용 가능</span>
- <span style="color:9999ff">리액티브 프로그래밍</span>: 스프링 프레임워크 5.0에 포함된 새로운 패러다임의 리액티브 프로그래밍, 대규모 사용자가 지속적으로 증가하는 시스템을 만들다 보면, 흔들림 없이 견고한 접근 방법이 필요해진다. 이런 하이엔드 시스템은 비동기적으로 인입되는 거의 무제한의 데이터 스트림을 논블로킹 방식으로 처리할 수 있어야 한다.

<hr>

## 리액티브 프로그래밍 소개
개발자들은 기존 자원을 더 효율적이고 일관성 있게 사용하는 방법을 찾고 있으며, 그 해법이 바로 액티브 스트림 *Reactive Stream* 이다.
- - - 
#### 리액티브 스트림
발행자*publisher* 와 구독자*subscriber* 사이의 간단한 계약을 정의하는 명세다. 트래픽을 가능한 한 빨리 발행하는 대신에 구독자가 '난 10개만 더 받을 수 있어.' 라고 발행자에게 알리는 상식으로 트래픽을 제어할 수 있다. 그러면 발행자는 10개만 더 보낸다.

기업 간 시스템을 발행자와 구독자 관계로 연결하면 시스템 범위의 배압*backpressure* 을 적용할 수 있다. 트래픽을 잘 조절해서 관리할 수 있는 장점.
- - -
<span style="font-size:13px">배압 : 구독자가 스스로 처리할 수 있을 만큼의 데이터만을 발행자에게 요청해서 데이터 전송량을 조절할 수 있는 메커니즘
- - - 
#### 프로젝트 리엑터
프로젝트 리엑터*Project Reactor*는 VM웨어에서 만든 리액티브 스트림 구현체다. 리액터를 사용하면 다음 특성을 따르는 리액티브 프로그래밍을 활용할 수 있게 된다.

- 논블로킹, 비동기 프로그래밍 모델
- 함수형 프로그래밍 스타일
- 스레드를 신경 쓸 필요 없는 동시성
- - -
#### 리액터 타입
리액티브 스트림은 수요 조절에 기반하고 있다. 프로젝트 리액터는 핵심 타입인 Flux&lt;T>를 사용해서 수요 조절을 구현한다. Flux&lt;T>는 일련의 T 객체를 담고 있는 컨테이너다.
Flux&lt;T>는 실제 물건을 전달해주는 역할을 하는 플레이스홀더*placeholder*로, 쉽게 말해 레스토랑에서 일하는 서빙 점원과 비슷하다고 할 수 있다. 주방에서 요리가 완성되면, 점원이 주방에서 요리를 받아 손님에게 가져다주고, 다시 제자리로 돌아와서 다음 요리를 기다린다.

서빙 점원은 다음 요리가 언제 완성될지 알 수 없다. 언제가 됐든 요리가 완성되고, 서빙 점원이 그 요리를 받아서 전달할 수 있는 상태라면, 다음 요리를 손님에게 가져다준다.
```java
class KitchenService{
	Flux<Dish> getDishes(){
		return Flux.just(
			new Dish("chicken"),
			new Dish("noodles"),
			new Dish("sour beef")
		);
	}
}
```

서빙 점원은 손님에게 가져다줄 Dish(요리) 객체를 달라고 KitchenService에 요청할 수 있다.
코드에 나온 세 가지 요리가 모두 완성된 후에 받을 수도 있지만, Flux&lt;DIsh> 객체로 바로 받을 수도 있다. 요리는 정확히 언제 완성될지는 알 수 없다.

하지만 요리가 완성되면 서빙 점원은 행동에 나설 수 있다. 즉 요리 완성에 대한 반응 행동, 리액트*react*라고 할 수 있다. 리액터는 논블로킹 방식으로 동작하기 때문에, 주방에서 요리가 완성될 때까지 서빙 점원(서버 스레드)이 다른 일을 못 한 채 계속 기다리게 하지 않는다.

결과가 아직 정해지지 않았고 미래 어느 시점이 되어야 알 수 있다는 점에서 Flux는 Future와 비슷하다. 결과를 미래에 알 수 있다는 관점에서는 비슷하지만, Future는 이미 시작되었음을 나타내는 반면, Flux는 시작할 수 있음을 나타낸다.

그렇다면 Future는 제공해주지 않지만 Flux는 제공해주는 것은 무엇일까?
- 하나 이상의 Dish(요리) 포함 가능
- 각 Dish(요리)가 제공될 때 어떤 일이 발생하는지 지정 가능
- 성공과 실패의 두 가지 경로 모두에 대한 처리 방향 정의 가능
- 결과 폴링*polling* 불필요
- 함수형 프로그래밍 지원

이제 좀 더 많은 코드를 작성해보면서 서빙 점원이 요리를 손님에게 비동기적으로 가져다주는 개념을 머릿속에 각인해보자.
```java
class SimpleServer {
	
	private final KitchenService kitchen;
	SimpleServer(KitchenService kitchen) {
		this.kitchen = kitchen;
	}
	
	Flux<Dish> doingMyJob(){
		return this.kitchen.getDishes()
			.map(dish -> Dish.deliver(dish));
	}
}
```
평범한 서빙 점원은 다음과 같은 특징이 있다.
- `SimpleServer` 인스턴스를 생성하는 쪽에서 `KitchenService`를 제공해야 한다. 이런 방식을 생성자 주입*constructor injection*이라고 한다.
- `doingMyJob()` 함수는 레스토랑 매니저가 서빙 점원을 툭 치면, `kitchen`(주방)에 가서 요리를 받아오는 `getDishes()` 임무를 수행하는 것으로 생각할 수 있다.
- 주방에 요리를 요청한 후에는 요리 완성 후 해야 할 일을 `map()` 함수를 호출해서 지정한다. 예제에서는 `deliver(dish)`를 호출해서 요리를 손님에게 가져다주는 일을 지정했다.
- `deliver(dish)`는 요리의 delivered 상태를 `true`로 설정한다.

프로젝트 리액터는 풍부한 프로그래밍 모델을 제공한다. 함수형 프로그래밍에서 수행하는 변환뿐만 아니라, `onNext()`, 'onError()', 'onComplete()' 시그널처럼 Future 객체에는 없는 리액티브 스트림 생명주기에 연결 지을 수도 있다.

이제 리액티브 스트림 생명주기를 이해하기 위해 서빙 점원을 만들어보자.
```java
class PoliteServer{

	@AutoWired
	private KitchenService kitchen;

	Flux<Dish> doingMyJob() {
		return this.kitchen.getDishes()
			.doOnNext()
	}
}
```